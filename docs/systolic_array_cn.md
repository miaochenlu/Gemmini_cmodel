# Gemmini 脉动阵列设计文档

## 概述

脉动阵列（Systolic Array）是 Gemmini 加速器的核心计算引擎，专为高效执行矩阵乘法和卷积运算而设计。它由规则排列的处理单元（PE）组成，数据在 PE 之间以脉动方式流动，实现高并行度和高效能的计算。

## 架构设计

### 基本结构

Gemmini 的脉动阵列采用二维网格结构，由 M×N 个处理单元组成：

- 行数（M）：通常是计算矩阵高度的并行度
- 列数（N）：通常是计算矩阵宽度的并行度

```
      +----+----+----+----+
      | PE | PE | PE | PE |
      +----+----+----+----+
      | PE | PE | PE | PE |
      +----+----+----+----+
      | PE | PE | PE | PE |
      +----+----+----+----+
      | PE | PE | PE | PE |
      +----+----+----+----+
```

### PE 与脉动阵列的关联

每个 PE 通过四个方向的连接与相邻 PE 通信：

```
                 上方 PE 的权重
                      ↓
                 +--------+
左方 PE 的数据 → |   PE   | → 右方 PE 的数据
                 +--------+
                      ↓
                 下方 PE 的权重


       详细的 PE 间连接:

       +-----+    数据    +-----+    数据    +-----+
       | PE  |----------->| PE  |----------->| PE  |
       |     |            |     |            |     |
       +-----+            +-----+            +-----+
          ↑                  ↑                  ↑
       权重                权重               权重
          |                  |                  |
       +-----+    数据    +-----+    数据    +-----+
       | PE  |----------->| PE  |----------->| PE  |
       |     |            |     |            |     |
       +-----+            +-----+            +-----+
          ↑                  ↑                  ↑
       权重                权重               权重
          |                  |                  |
       +-----+    数据    +-----+    数据    +-----+
       | PE  |----------->| PE  |----------->| PE  |
       |     |            |     |            |     |
       +-----+            +-----+            +-----+
```

### 数据流模式

脉动阵列支持的主要数据流模式：

1. **权重固定模式**：

   - 权重矩阵在 PE 中保持不变
   - 激活数据从左到右流动
   - 适合卷积神经网络的推理阶段

2. **输出固定模式**：
   - 部分和在 PE 中累积
   - 权重从上到下流动
   - 激活数据从左到右流动
   - 适合批量矩阵乘法运算

```
          数据流动
          ↓ ↓ ↓ ↓
        +→+→+→+→+
权重流动→+→+→+→+→+
        +→+→+→+→+
        +→+→+→+→+
```

## 数据流动机制

### 数据加载和分发

1. **权重加载**：

   - 从主存储器加载到片上缓冲区
   - 按行或列分发到相应的 PE

2. **激活数据加载**：
   - 从主存储器加载到片上缓冲区
   - 顺序分发到第一列 PE

### 数据传递模式

1. **空间广播**：一个值同时发送到多个 PE
2. **时间复用**：同一数据在不同时间点重复使用
3. **空间脉动**：数据从一个 PE 传递到相邻 PE

### 结果收集

计算完成后，结果可以通过以下两种方式收集：

1. 从每个 PE 直接读取最终结果
2. 结果值在 PE 之间流动并在边缘 PE 收集

## SPARTA 建模实现

### 建模架构

Gemmini 脉动阵列使用 SPARTA（Simulation Platform for ARchiTecture Analysis）框架进行建模。SPARTA 是一个事件驱动的 C++模拟框架，允许精确建模处理器微架构和加速器。

主要建模组件:

- **TreeNode 结构**: 以层次化方式组织脉动阵列的各个组件
- **Unit 类**: 每个 PE 继承自 sparta::Unit
- **资源事件**: 使用 sparta::Event 跟踪和调度操作
- **时间驱动**: 基于 sparta::Scheduler 实现精确的时钟周期控制

### 组件模型化

```
+---------------+
| SystolicArray |
+---------------+
        |
        v
+----------------------+
| PEArray (2D Grid)    |
+----------------------+
        |
        v
+----------------------+
| PE (Processing Unit) |
+----------------------+
        |
        v
+--------------------+
| Port Interface     |
+--------------------+
```

### 事件模型

SPARTA 使用事件驱动模型来仿真 PE 和脉动阵列的行为:

1. **事件注册**: 每个 PE 注册时钟事件和数据/控制事件
2. **事件调度**: 根据时钟周期调度计算和数据传输事件
3. **事件处理**: 在每个时钟周期处理已调度的事件

```
时钟周期: |  0  |  1  |  2  |  3  |  4  |  5  |
事件调度: Tick→ Tick→ Tick→ Tick→ Tick→ Tick→
         |     |     |     |     |     |
数据事件: 加载→ 传输→ 计算→ 传输→
         |     |     |     |     |
控制事件: 配置→       |     |    读取→
```

## 周期实现与控制

### 周期粒度

Gemmini 脉动阵列的 SPARTA 模型采用以下周期粒度:

1. **基本时钟周期**: 系统的基本时间单位，通常为硬件时钟周期
2. **计算周期(compute*time*)**: 每个 PE 执行一次 MAC 操作所需的周期数
   - PE 中的`compute_time_`参数决定每次 MAC 操作需要多少个基本时钟周期
   - 在当前实现中，设置为 0 个周期，表示 MAC 操作在同一周期内完成

### 周期精确建模

```cpp
// PE的tick_方法示例（周期控制的核心）
void PE::tick_()
{
    if (busy_) {
        // 由于MAC操作需要0个周期，以下代码在实际执行时可能被优化
        if (cycle_counter_ > 0) {
            --cycle_counter_;
        }

        if (cycle_counter_ == 0) {
            busy_ = false;
        }
    }

    // 调度下一个时钟周期
    tick_event_.schedule(1);  // 1表示下一个周期
}
```

### 控制流实现

脉动阵列的控制流通过 SPARTA 的事件机制实现:

1. **启动序列**:

   - 初始化所有 PE 的状态
   - 创建并注册`StartupEvent`以初始化时钟事件

2. **运行时控制**:

   - 每个 PE 维护自己的状态
   - 控制单元发送控制信号(如 RESET=1, READ=2)到各个 PE

3. **数据流控制**:
   - 通过 Port 接口控制权重和数据的流动
   - 使用事件调度机制确保正确的时序

### 周期统计

系统收集以下周期相关的统计信息:

1. **总 MAC 操作数**: 每个 PE 统计执行的 MAC 操作总数
2. **有效周期利用率**: 计算阵列的周期利用效率
3. **计算延迟**: 特定运算的总周期数

```cpp
// 统计计数器示例
total_macs_(getStatisticSet(), "total_macs", "Count of MAC operations", sparta::Counter::COUNT_NORMAL)
```

## 时序控制

### 计算周期

脉动阵列的计算周期由以下因素决定：

- PE 的 MAC 操作时间
  - MAC 操作需要 0 个周期，即在同一周期内即可完成计算
- 数据传输延迟
  - PE 间数据传输需要 1 个周期
- 阵列大小
- 计算矩阵的维度

### 启动和冲刷时间

对于 M×N 的脉动阵列：

- **启动时间**：M+N-1 个周期（阵列完全填充所需时间）
- **冲刷时间**：M+N-1 个周期（最后一个结果输出所需时间）
- **全流水线效率**：在大矩阵上接近 100%，但小矩阵受启动/冲刷开销影响

### 时序图实例

以下时序图展示了一个 4×4 脉动阵列进行矩阵乘法的典型周期，考虑到 MAC 操作为 0 周期:

```
周期:  |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |
      +-----+-----+-----+-----+-----+-----+-----+-----+
PE11:  |     | 接收 | 接收 | 接收 | 接收 | 接收 | 接收 |     |
      | MAC | MAC | MAC | MAC | MAC | MAC | MAC |     |
      +-----+-----+-----+-----+-----+-----+-----+-----+
PE12:  |     |     | 接收 | 接收 | 接收 | 接收 | 接收 | 接收 |
      |     | MAC | MAC | MAC | MAC | MAC | MAC | MAC |
      +-----+-----+-----+-----+-----+-----+-----+-----+
PE21:  |     |     | 接收 | 接收 | 接收 | 接收 | 接收 | 接收 |
      |     | MAC | MAC | MAC | MAC | MAC | MAC | MAC |
      +-----+-----+-----+-----+-----+-----+-----+-----+
PE22:  |     |     |     | 接收 | 接收 | 接收 | 接收 | 接收 |
      |     |     | MAC | MAC | MAC | MAC | MAC | MAC |
      +-----+-----+-----+-----+-----+-----+-----+-----+
      调度  阵列填充阶段           数据流动阶段
```

_注: 由于 MAC 为 0 周期，数据接收和 MAC 操作在同一周期内完成_

## 优化技术

### 数据重用

1. **时间重用**：同一数据在不同时间点被多个 PE 使用
2. **空间重用**：同一数据同时被多个 PE 使用

### 稀疏性处理

1. **零跳过**：检测并跳过零值计算
2. **动态脉动**：根据稀疏模式动态调整数据流动

### 精度优化

1. **混合精度**：支持不同位宽的数据类型
2. **量化**：将浮点数转换为低位宽整数
3. **累加器精度**：使用更高精度的累加器避免溢出

## 与其他模块交互

### 存储层次结构

1. **寄存器文件**：PE 内部临时存储
2. **脉动阵列缓冲区**：为阵列提供输入数据
3. **暂存缓冲区**：存储阵列输出结果
4. **DRAM 接口**：与主存储器交互

### 系统架构图

```
+-------------------+       +-------------------+
|                   |       |                   |
|   DRAM控制器      |<----->|     主存储器      |
|                   |       |                   |
+-------------------+       +-------------------+
         ↑
         |
+-------------------+       +-------------------+
|                   |       |                   |
|   片上缓冲区      |<----->|    控制单元       |
|                   |       |                   |
+-------------------+       +-------------------+
         ↑                           ↑
         |                           |
         ↓                           ↓
+---------------------------------------------------+
|                                                   |
|                    脉动阵列                        |
|                                                   |
|    +-----+  +-----+  +-----+  +-----+            |
|    | PE  |  | PE  |  | PE  |  | PE  |  ...       |
|    +-----+  +-----+  +-----+  +-----+            |
|                                                   |
|    +-----+  +-----+  +-----+  +-----+            |
|    | PE  |  | PE  |  | PE  |  | PE  |  ...       |
|    +-----+  +-----+  +-----+  +-----+            |
|                                                   |
|    ...      ...      ...      ...                |
|                                                   |
+---------------------------------------------------+
```

### 控制单元

控制单元负责：

1. **数据流调度**：确定数据何时加载和流动
2. **PE 配置**：设置计算模式和参数
3. **同步控制**：管理启动和冲刷阶段

## 性能指标

### 计算吞吐量

对于 M×N 阵列，每个周期执行 M×N 个 MAC 操作：

- **峰值吞吐量**：M×N× 频率 MAC/秒
- **有效吞吐量**：受数据移动和阵列利用率影响

### 能效

影响能效的因素：

1. **数据移动成本**：通常比计算成本高
2. **阵列利用率**：空 PE 会消耗静态功率
3. **时钟频率**：更高频率提高吞吐量但增加功耗

### 资源使用

1. **计算资源**：PE 数量和结构
2. **存储资源**：缓冲区大小和带宽
3. **互连资源**：PE 之间和 PE 与缓冲区之间的连接

## 矩阵乘法映射

### 基本映射策略

对于矩阵乘法 C = A × B：

1. A 的行沿 PE 行方向映射
2. B 的列沿 PE 列方向映射
3. C 的元素在相应的 PE 中累积

```
   矩阵A      矩阵B       矩阵C
  [a11 a12]  [b11 b12]  [c11 c12]
  [a21 a22]  [b21 b22]  [c21 c22]

  映射到2×2脉动阵列：

  时刻1: a11→PE11, b11→PE11
  时刻2: a12→PE11, b21→PE11, a11→PE12, b12→PE12
  时刻3: a22→PE21, b21→PE21, a21→PE22, b22→PE22
  时刻4: a22→PE21, b22→PE21
```

### 大矩阵处理

当矩阵维度超过阵列大小时：

1. **分块处理**：将大矩阵分解为适合阵列大小的块
2. **时间复用**：阵列被重复使用处理不同的块
3. **结果累积**：部分结果存储在缓冲区中并最终合并

## 卷积操作映射

### 直接卷积映射

将卷积内核权重加载到 PE 中，输入特征图数据流过阵列：

1. 权重重用：每个卷积核在多个输出位置共享
2. 输入重用：每个输入在多个卷积窗口中使用

### Im2Col 转换

将卷积操作转换为矩阵乘法：

1. 输入特征图展开为列
2. 卷积核展开为行
3. 使用标准矩阵乘法映射

## 调试与测试

### 常见问题

1. **数据同步**：确保数据在正确的时间到达正确的 PE
2. **边界条件**：处理阵列边缘的特殊情况
3. **精度控制**：防止累积误差和溢出

### 测试方法

1. **单元测试**：验证单个 PE 的正确性
2. **集成测试**：验证 PE 之间的数据流和通信
3. **端到端测试**：验证完整矩阵运算的正确性
